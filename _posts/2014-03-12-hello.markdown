---
category: hello
---

Modern development is highly asynchronous: isn’t it about time iOS developers had tools that made programming asynchronously powerful, easy and delightful?

PromiseKit is not just a [Promises](http://wikipedia.org/wiki/Promise_%28programming%29) implementation, it is also a collection of helper functions that make the typical asynchronous patterns we use in iOS development delightful *too*.

PromiseKit is also designed to be integrated into other CocoaPods. If your library has asynchronous operations and you like PromiseKit, then add an opt-in subspec that provides Promises for your users. Documentation to help you integrate PromiseKit into your own pods is provided later in this guide.

<script>
function foo(rsp) {
  if (rsp.meta.status == 200) {
    var pulse = document.getElementById("pulse");
    pulse.innerHTML = "★" + rsp.data.stargazers_count;
  }
}

var script = document.createElement('script');
script.src = 'https://api.github.com/repos/mxcl/PromiseKit?access_token=c826b3e99f4be66fd134ebabd070e61159ab4d7a&callback=foo';

document.getElementsByTagName('head')[0].appendChild(script);
</script>

<a class="github" href="https://github.com/mxcl/PromiseKit">PromiseKit on GitHub</a> <span id="pulse"></span>


#Importing PromiseKit

In your [Podfile](http://guides.cocoapods.org/using/using-cocoapods.html):

{% highlight ruby %}
pod 'PromiseKit'
{% endhighlight %}

In your `.m` files:

{% highlight c %}
#import "PromiseKit.h"
{% endhighlight %}

PromiseKit is modulized; if you only want `Promise` and none of our category additions:

{% highlight ruby %}
pod 'PromiseKit/base'
{% endhighlight %}

Or if you only want some of our categories:

{% highlight ruby %}
pod 'PromiseKit/Foundation'
pod 'PromiseKit/UIKit'
pod 'PromiseKit/CoreLocation'
pod 'PromiseKit/MapKit'
{% endhighlight %}


#Why Promises?

Synchronous code is clean code. For example, here's the synchronous code to show a gravatar image:

{% highlight objectivec %}
id md5 = md5(email);
id url = [@"http://gravatar.com/" stringByAppendingString:md5];
id data = [NSData dataWithContentsOfURL:[NSURL URLWithString:url]];
self.imageView.image = [UIImage imageWithData:data];
{% endhighlight %}

Clean but blocking: the UI lags: the user rates you one star.

The asynchronous analog suffers from *rightward-drift*:

{% highlight objectivec %}
id q1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
id q2 = [NSOperationQueue new];
dispatch_async(q1, ^{
    id md5 = md5(email);
    id url = [@"http://gravatar.com/" stringByAppendingString:md5];
    id rq = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];
    [NSURLConnection sendAsynchronousRequest:rq queue:q2
                           completionHandler:^(id rsp, id data, id err) {
        UIImage *gravatarImage = [UIImage imageWithData:data];
        dispatch_async(dispatch_get_main_queue(), ^{
            self.imageView.image = gravatarImage;
        });
    }];
});
{% endhighlight %}

The code that does the actual work is now buried inside asynchronicity boilerplate. It is harder to read. The code is less clean.

Promises are chainable, standardized representations of asynchronous tasks. The equivalent code with PromiseKit looks like this:

{% highlight objectivec %}
#import "PromiseKit.h"

dispatch_promise(^{
    return md5(email);
}).then(^(NSString *md5){
    return [NSURLConnection GET:@"http://gravatar.com/%@", md5];
}).then(^(UIImage *gravatarImage){
    self.imageView.image = gravatarImage;
});
{% endhighlight %}

Code with promises is about as close as we can get to the minimal cleanliness of synchronous code.


##Chaining Promises

A `Promise` represents the *future* value of an asynchronous task. To obtain the value of that future, we `then` off the Promise.

{% highlight objectivec %}
Promise *promise = dispatch_promise(^{
    // we’re in a background thread
    return md5(email);
});

// `dispatch_promise` executes its block via `dispatch_async`.
// It returns a Promise. When the block has executed it
// fulfills its promise with the value you return from that
// block.

promise = promise.then(^(NSString *md5){
    // we’re back in the main thread
    // the `md5` came from the above `dispatch_promise`
    return [NSURLConnection GET:@"http://gravatar.com/%@", md5];
});

// Returning a promise from a `then` handler effectively
// splices that promise into the chain.

promise.then(^(UIImage *gravatarImage){
    // Our NSURLConnection category addition determined the
    // data represented an image by analysing the response
    // headers and instantiated a `UIImage` in a background
    // thread.
    self.imageView.image = gravatarImage;
});
{% endhighlight %}


#Error Handling

Synchronous code has simple, clean error handling:

{% highlight objectivec %}
@try {
    id md5 = md5(email);
    id url = [@"http://gravatar.com/" stringByAppendingString:md5];
    url = [NSURL URLWithString:url];
    id error;
    id data = [NSData dataWithContentsOfURL:url options:0 error:&error];
    if (error) @throw error;
    self.imageView.image = [UIImage imageWithData:data];
} @catch (id thrownObject) {
    //…
}
{% endhighlight %}

Error handling with asynchronous code is notoriously tricky. Here's an example using `NSURLConnection`, CoreLocation and MapKit:

{% highlight objectivec %}
void (^errorHandler)(NSError *) = ^(NSError *error){
    //…
};

id url = [NSURL URLWithString:@"http://example.com/user.json"];
id rq = [NSURLRequest requestWithURL:url];
id q = [NSOperationQueue new];

[NSURLConnection sendAsynchronousRequest:rq queue:q
                       completionHandler:^(id rsp, id data, id error) {
    if (error)
        return errorHandler(error);
    id json = [NSJSONSerialization JSONObjectWithData:data options:0 error:&error];
    if (error)
        return errorHandler(error);
    id home = [json valueForKeyPath:@"user.home.address"];
    [[CLGeocoder new] geocodeAddressString:home
                         completionHandler:^(id placemarks, id error) {
        if (error)
            return errorHandler(error);
        id placemark = [[MKPlacemark alloc] initWithPlacemark:placemarks[0]];
        MKDirectionsRequest *rq = [MKDirectionsRequest new];
        rq.source = [MKMapItem mapItemForCurrentLocation];
        rq.destination = [[MKMapItem alloc] initWithPlacemark:placemark];
        id directions = [[MKDirections alloc] initWithRequest:rq];
        [directions calculateDirectionsWithCompletionHandler:^(id rsp, id error) {
            if (error) {
                errorHandler(error);
            } else {
                //…
            }
        }];
    }];
}];
{% endhighlight %}

The repeated, explicit error handling clutters the code.

Promises have elegant error handling:

{% highlight objectivec %}
#import "PromiseKit.h"

[NSURLConnection GET:@"http://example.com/user.json"].then(^(id json){
    id home = [json valueForKeyPath:@"user.home.address"];
    return [CLGeocoder geocode:home];
}).then(^(CLPlacemark *placemark){
    MKDirectionsRequest *rq = [MKDirectionsRequest new];
    rq.source = [MKMapItem mapItemForCurrentLocation];
    rq.destination = [[MKMapItem alloc] initWithPlacemark:placemark];
    return [MKDirections promise:rq];
}).then(^(MKDirectionsResponse *directions){
    //…
}).catch(^(NSError *error){
    //…
});
{% endhighlight %}

Errors and exceptions break the chain of promises and bubble up to the next `catch` handler. In the case of exceptions, objects are caught and wrapped in an NSError object. The original thrown object is accessible via `error.userInfo[PMKUnderlyingExceptionKey]`.

This tends to work well for asynchronous chains; typically you want to know if the whole chain succeeded or the whole chain failed. You don’t want to micromanage the error handling every step of the way.

The above makes use of PromiseKit’s category additions to the iOS SDK. Mostly PromiseKit’s categories are logical conversions of block-based or delegate-based asynchronous patterns to Promises. `NSURLConnection+PromiseKit` additionally detects that the response is JSON (from the HTTP headers) and deserializes that JSON in a background thread. All of PromiseKit’s categories are optional CocoaPods subspecs.


#Say Goodbye to Asynchronous State Machines

Promises represent the future value of a task. You can add more than one `then` handler to a promise. Even after the promise has been fulfilled. If the promise already has a value the then handler is called (almost) immediately:

{% highlight objectivec %}
@implementation MyViewController {
    Promise *gravatar;
}

- (void)viewDidLoad {
    gravatar = dispatch_promise(^{
        return md5(email);
    }).then(^(NSString *md5){
        return [NSURLConnection GET:@"http://gravatar.com/%@", md5];
    });

    gravatar.then(^(UIImage *image){
        self.imageView.image = image;
    });
}

- (void)someTimeLater {
    gravatar.then(^(UIImage *image){
        // Called (almost) immediately, or later. Either way: we’re covered.
        self.otherImageView.image = image;
    });
}

@end
{% endhighlight %}

Promises can only exist in two states, *pending* or *resolved*. The resolved state is either fulfilled or rejected (an `NSError` object). A Promise can move from pending to resolved **exactly once**. Whichever state the Promise is in, you can `then` off it.


#Waiting on Multiple Asynchronous Operations

One common reason to use asynchronous variants is so we can do two or more asynchronous operations simultaneously. However writing code that acts when all the simultaneous operations have completed is tricky and bug-prone. Not so with PromiseKit:

{% highlight objectivec %}
Promise *grabcat = [NSURLConnection GET:@"http://placekitten.org/%d/%d", w, h];
Promise *locater = [CLLocationManager promise];

[Promise when:@[grabcat, locater]].then(^(NSArray *results){
    // results[0] is the `UIImage *` from grabcat
    // results[1] is the `CLLocation *` from locater
}).catch(^(NSError *error){
    // if any Promises fail, the `catch` handler is executed
    // immediately any other Promises are discarded
    
    NSNumber *indexOfPromiseThatFailed = error.userInfo[PMKFailingPromiseIndexKey];
});
{% endhighlight %}

`when:` also takes an `NSDictionary`, and thus `then`s an `NSDictionary`:

{% highlight objectivec %}
id dict = @{
    @"grabcat": grabcat,
    @"locater": locater
};

[Promise when:dict].then(^(NSDictionary *results){
    // results[@"grabcat"] is the `UIImage *` from grabcat
    // results[@"locater"] is the `CLLocation *` from locater
}).catch(^(NSError *error){
    NSString *keyOfPromiseThatFailed = error.userInfo[PMKFailingPromiseIndexKey];
});
{% endhighlight %}


#Unusually Tolerant Syntax

The block you pass to `then` or `catch` can have return type of `Promise`, or any object, any primitive, or nothing. And it can have a parameter of `id`, or a specific class type, or nothing, or even multiple parameters (if the previous Promise fulfilled with multiple values).

So all of these are valid:

{% highlight objectivec %}
myPromise.then(^{
    // no return
});

myPromise.then(^(id obj){
    // no return
});

myPromise.then(^(id obj){
    return @1;
});

myPromise.then(^{
    return @2;
});
{% endhighlight %}

Clang is smart so you don’t (usually) have to specify a return type for your block.

This is not usual to Objective-C or blocks. Usually everything is very explicit. We are using introspection to determine what arguments and return types you are working with. Thus, programming with PromiseKit has similarities to programming with (more) modern languages like Ruby or Javascript.

In fact these (and more) are also fine:

{% highlight objectivec %}
myPromise.then(^{
    return 1;
}).then(^(NSNumber *n){
    assert([n isEqual:@1]);
});

myPromise.then(^{
    return false;
}).then(^(NSNumber *n){
    assert([n isEqual:@NO]);
});
{% endhighlight %}


#finally

We also provide `finally` which runs if the Promise has been rejected or resolved:

{% highlight objectivec %}
self.kitten.then(^(UIImage *image){
    // runs if kitten succeeded
}).catch(^(NSError *err){
    // runs if kitten failed
}).finally(^{
    // always runs
});
{% endhighlight %}

The block you pass to `finally` cannot take or return arguments: it cannot change the Promise.


#thenOn

`then` always runs on the main thread. Using `thenOn` allows you to choose the queue on which your block will continue. When in doubt: `then`.


#The Category Additions

PromiseKit aims to provide a category analog for all one-time asynchronous operations in the iOS SDK.

Notably we don’t provide a Promise for eg. `UIButton` actions. Promises can only resolve once, and buttons can be pushed again and again.


##NSURLConnection+PromiseKit

{% highlight objectivec %}
#import "PromiseKit+Foundation.h"

[NSURLConnection GET:@"http://promisekit.org"].then(^(NSData *data){
    
}).catch(^(NSError *error){
    NSHTTPURLResponse *rsp = error.userInfo[PMKURLErrorFailingURLResponseKey];
    int HTTPStatusCode = rsp.statusCode;
});
{% endhighlight %}

And a convenience string format variant:

{% highlight objectivec %}
[NSURLConnection GET:@"http://example.com/%@", folder].then(^{
    //…
});
{% endhighlight %}

And a variant that constructs a correctly URL encoded query string from a dictionary:

{% highlight objectivec %}
[NSURLConnection GET:@"http://example.com" query:@{@"foo": @"bar"}].then(^{
    //…
});
{% endhighlight %}

And a POST variant:

{% highlight objectivec %}
[NSURLConnection POST:@"http://example.com" formURLEncodedParameters:@{@"key": @"value"}].then(^{
    //…
});
{% endhighlight %}

PromiseKit reads the response headers and decodes the result you actually wanted (in a background thread):

{% highlight objectivec %}
[NSURLConnection GET:@"http://example.com/some.json"].then(^(NSDictionary *json){
    assert([json isKindOfClass:[NSDictionary class]]);
});

[NSURLConnection GET:@"http://placekitten.org/100/100"].then(^(UIImage *image){
    assert([image isKindOfClass:[UIImage class]]);
});
{% endhighlight %}

If the mime-type is textual, we return an `NSString`. Otherwise the first parameter will be the raw undecoded `NSData`. Whatever the mimetype the `then` has three optional parameters: the first is the decoded data, the second the `NSHTTPURLResponse` and the third the raw undecoded data.

Finally we provide a variant that takes an `NSURLRequest *`:

{% highlight objectivec %}
NSMutableURLRequest *rq = [NSMutableURLRequest requestWithURL:url];
[rq addValue:@"PromiseKit" forHTTPHeader:@"User-Agent"]; 
[NSURLConnection promise:rq].then(^(NSData *data){
    //…
})
{% endhighlight %}


##CLLocationManager+PromiseKit

A Promise to get the user’s location:

{% highlight objectivec %}
#import "PromiseKit+CoreLocation.h"

[CLLocationManager promise].then(^(CLLocation *currentUserLocation){
    //…
}).catch(^(NSError *error){
    //…
});
{% endhighlight %}

The `then` has an optional second parameter that is the full array of returned locations. Which usually is an array of one location. The first parameter is the most recent location.


##CLGeocoder+PromiseKit

{% highlight objectivec %}
#import "PromiseKit+CoreLocation.h"

[CLGeocoder geocode:@"mount rushmore"].then(^(CLPlacemark *firstPlacemark){
    //…
}).catch(^(NSError *error){
    //…
});

CLLocation *someLocation = …;
[CLGeocoder reverseGeocode:someLocation].then(^(CLPlacemark *firstPlacemark){
    //…
}).catch(^(NSError *error){
    //…
});
{% endhighlight %}

`CLGeocoders` asynchronously return one or *more* placemarks. The Promise thens the first placemark, and as the optional second parameter, all the placemarks (which often is just an array of one item). So if you want to check all placemarks, ensure you `then` two parameters.


##UIAlertView+PromiseKit

A promise for showing a `UIAlertView`:

{% highlight objectivec %}
#import "PromiseKit+UIKit.h"

UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"You Didn’t Save!"
                      message:@"You will lose changes."
                     delegate:nil
            cancelButtonTitle:@"Cancel"
            otherButtonTitles:@"Lose Changes", @"Panic", nil];

alert.promise.then(^(NSNumber *dismissedIndex){
    //…
});
{% endhighlight %}

This promise will not trigger a `catch` handler. At one point we had the cancel button trigger `catch`, but this led to unreliable error handling. **Only errors trigger `catch` handlers**.

The promise optionally thens the `UIAlertView` instance as the second parameter, should you need it.


##UIActionSheet+PromiseKit

Same pattern as for `UIAlertView`.


##UIViewController+PromiseKit

We provide a pattern for modally presenting ViewControllers and getting back a result:

{% highlight objectivec %}
#import "PromiseKit+UIKit.h"

@implementation MyRootViewController

- (void)foo {
    UIViewController *vc = [MyDetailViewController new];
    [self promiseViewController:vc animated:YES completion:nil].then(^(id result){
        // the result from below in `someTimeLater`
        // PromiseKit automatically dismisses the MyDetailViewController
    });
}

@end

@implementation MyDetailViewController

- (void)someTimeLater {
    [self fulfill:someResult];
    
    // if you want to trigger the `catch` use `[self reject:foo]`
}

@end
{% endhighlight %}

As a bonus if you pass a `MFMailComposeViewController` we handle its delegation behind the scenes and convert it into a Promise:

{% highlight objectivec %}
id mailer = [MFMailComposerViewController new];
[self promiseViewController:mailer animated:YES completion:nil].then(^(NSNumber *n){
    // num is the result passed from the MFMailComposeViewControllerDelegate
}).catch(^{
    // the error from the delegate if that happened
});
{% endhighlight %}

Please submit equivalents for eg. `UIImagePickerController`.


##MKDirections+PromiseKit

{% highlight objectivec %}
#import "PromiseKit+MapKit.h"

MKDirectionsRequest *rq = [MKDirectionsRequest new];
rq.source = [MKMapItem mapItemForCurrentLocation];
rq.destination = …;
[MKDirections promise:rq].then(^(MKDirectionsResponse *rsp){
    //…
}).catch(^{
    //…
});

[MKDirections promiseETA:rq].then(^(MKETAResponse *rsp){
    //…
}).catch(^{
    //…
});
{% endhighlight %}


##MKMapSnapshotter+PromiseKit

{% highlight objectivec %}
#import "PromiseKit+MapKit.h"

MKSnapshotter *snapshotter = [MKSnapshotter new];
snapshotter.region = …;
[snapshotter promise].then(^(MKMapSnapshot *snapshot){
    //…
}).catch(^{
    //…
});
{% endhighlight %}


##SocialFramework+PromiseKit

Available! See the headers.

##StoreKit+PromiseKit

Available, though just a start. See the headers.


#More Documentation

Check out [Promise.h](https://github.com/mxcl/PromiseKit/blob/master/PromiseKit/Promise.h) and the rest of the sources.

###Guides

* [Promises Pay](http://blog.popularpays.com/tech/2014/4/28/popular-promises)


#Promisizing Your Codebase

This:

{% highlight objectivec %}
- (void)calculateTenThousandRandomNumbersWithCompletionBlock:(void(^)(NSArray *))completionBlock {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSMutableArray *numbers = [NSMutableArray new];
        for (int x = 0; x < 10000; x++)
            [numbers addObject:@(arc4random())];
        dispatch_async(dispatch_get_main_queue(), ^{
            completionBlock(numbers);
        });
    });
}

- (void)viewDidLoad {
    [self calculateTenThousandRandomNumbersWithCompletionBlock:^(NSArray *numbers){
        //…
    }];
}
{% endhighlight %}

Becomes this:

{% highlight objectivec %}
- (Promise *)tenThousandRandomNumbers {
    return dispatch_promise(^{
        NSMutableArray *numbers = [NSMutableArray new];
        for (int x = 0; x < 10000; x++)
            [numbers addObject:@(arc4random())];
        return numbers;
    });
}

- (void)viewDidLoad {
    self.tenThousandRandomNumbers.then(^(NSArray *numbers){
        //…
    }];
}
{% endhighlight %}


##Wrapping e.g. Parse

{% highlight objectivec %}
- (Promise *)allUsers {
    return [Promise new:^(PromiseResolver fulfiller, PromiseResolver rejecter){
        PFQuery *query = [PFQuery queryWithClassName:@"User"];
        [query findObjectsInBackgroundWithBlock:^(NSArray *objects, NSError *error) {
            if (!error) {
                fulfiller(objects);
            } else {
                rejecter(error);
            }
        }];
    }];
}
{% endhighlight %}

`PromiseResolver` is `typedef void (^PromiseResolver)(id)`, i.e. a block that takes a parameter of `id` and returns `void`.

For the community’s benefit, someone should create a `Parse+PromiseKit` pod.


##Wrapping e.g. `AFNetworking`

{% highlight objectivec %}
@interface AFHTTPRequestOperation (PromiseKit)

- (Promise *)promise {
    return [Promise new:^(PromiseResolver fulfiller, PromiseResolver rejecter){
        [self setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *op, id responseObject){

            // PMKManifold allows you to fulfill promises with
            // multiple parameters.
            fulfiller(PMKManifold(responseObject, op));

            // We inverted the parameter order relative to the
            // AFNetworking completionBlock because promises order
            // their parameters from most to least important. Thus
            // consumers can `then` without the second parameter
            // if they don’t need it.

        }) failure:^(AFHTTPRequestOperation *op , NSError *error){
            rejecter(error);
        }];
    }];
}

@end
{% endhighlight %}

For the community’s benefit, someone should create an `AFNetworking+PromiseKit` pod.


##Wrapping a Delegate Pattern

Be cautious when wrapping delegate systems, Promises are **one shot**: they resolve once. Most delegate methods are able to be called more than once.

Consequently PromiseKit doesn’t wrap many delegate patterns yet (eg. UITextField+Delegate is not really appropriate) and where we do wrap them we have to do some anti-ARC hacks to prevent the delegating object from being prematurely released.

{% highlight objectivec %}
@implementation CLLocationManager (PromiseKit)

+ (Promise *)promise {
    [PMKLocationManager promise];
}

@end

@interface PMKLocationManager : CLLocationManager <CLLocationManagerDelegate>
@end

@implementation PMKLocationManager {
    PromiseFulfiller fulfiller;  // void (^)(id)
    PromiseRejecter rejecter;    // void (^)(NSError *)
}

+ (Promise *)promise {
    PMKLocationManager *manager = [PMKLocationManager new];
    manager.delegate = manager;
    [manager startUpdatingLocation];
    [manager pmk_reference];  // anti ARC hack
    return [Promise new:^(PromiseFulfiller fulfiller, PromiseRejecter rejecter){
        manager->fulfiller = fulfiller;
        manager->rejecter = rejecter;
    }];
}

- (void)locationManager:(id)manager didUpdateLocations:(NSArray *)locations {
    fulfiller(PMKManifold(locations.firstObject, locations));
    [self pmk_breakReference];  // anti ARC hack
}

- (void)locationManager:(id)manager didFailWithError:(NSError *)error {
    rejecter(error);
    [self pmk_breakReference];  // anti ARC hack
}

@end
{% endhighlight %}


#Adding Promises to Third Party Libraries

It would be great if every library with asynchronous functionality would offer opt-in `Promise *` variants for the asynchronous mechanisms.

Should you want to add PromiseKit integration to your library, the general premise is to add an opt-in `subspec` to your `podspec` that provides methods that return `Promise`s. For example if we imagine a library that overlays a kitten on an image:

{% highlight objectivec %}
@interface ABCKitten
- (instancetype)initWithImage:(UIImage *)image;
- (void)overlayKittenWithCompletionBlock:(void)(^)(UIImage *, NSError *))completionBlock;
@end
{% endhighlight %}

Opt-in PromiseKit support would include a new file `ABCKitten+PromiseKit.h`:

{% highlight objectivec %}
#import <PromiseKit/Promise.h>
#import "ABCKitten.h"


@interface ABCKitten (PromiseKit)

/**
 * Returns a Promise that overlays a kitten image.
 * @return A Promise that will `then` a `UIImage *` object.
 */
- (Promise *)overlayKitten;

@end
{% endhighlight %}

It's crucially important to document your Promise methods [properly](http://nshipster.com/documentation/), because subsequent `then`s are not strongly typed, thus the only clue the user has is how you named your method and the documentation they can get when **⌥** clicking that method.

Consumers of your library would then include in their `Podfile`:

{% highlight ruby %}
pod 'ABCKitten/PromiseKit'
{% endhighlight %}

This is the “opt-in” step.

Finally you need to modify your `podspec`. If it was something like this:

{% highlight ruby %}
Pod::Spec.new do |s|
  s.name         = "ABCKitten"
  s.version      = "1.1"
  s.source_files = 'ABCKitten.{m,h}'
end
{% endhighlight %}

Then you would need to convert it to the following:

{% highlight ruby %}
Pod::Spec.new do |s|
  s.name         = "ABCKitten"
  s.version      = "1.1"

  s.default_subspec = 'base'  # ensures that the PromiseKit additions are opt-in

  s.subspec 'base' do |ss|
    ss.source_files = 'ABCKitten.{m,h}'
  end

  s.subspec 'PromiseKit' do |ss|
    ss.dependency 'PromiseKit/base', 'ABCKitten/base'
    ss.source_files = 'ABCKitten+PromiseKit.{m,h}'
  end
end
{% endhighlight %}

##Adding PromiseKit to Someone Else’s Pod

Firstly you should try submitting the above to the project itself. If they won’t add it then you'll need to make your own pod. Use the naming scheme: `ABCKitten+PromiseKit`.


#Why PromiseKit?

There are other Promise implementations for iOS, but in this author’s opinion, none of them are as pleasant to use as PromiseKit.

* [Bolts](https://github.com/BoltsFramework/Bolts-iOS) was the inspiration for PromiseKit. I thought that—finally—someone had written a decent Promises implementation for iOS. The lack of dedicated `catch` handler, the (objectively) ugly syntax and the overly complex design was a disappointment. To be fair Bolts is not a Promise implementation, it’s…something else. You may like it, and certainly it is backed by big names™. Fundamentally, Promise-type implementations are not hard to write, so really you’re making a decision based on how flexible the API is while simulatenously producing readable, clean code. I have worked hard to make PromiseKit the best choice. Also PromiseKit is ***much* leaner** than Bolts.
* [RXPromise](https://github.com/couchdeveloper/RXPromise) is an excellent Promise implementation that is not quite perfect (IMHO). By default thens are executed in background threads, which usually is inconvenient. `then` always return `id` and always take `id`, which makes code less elegant. There is no explicit `catch`, instead `then` always takes two blocks, the second being the error handler, which is ugly. The interface for `Promise` allows any caller to resolve it breaking encapsulation. Otherwise an excellent implementation.
* [CollapsingFutures](https://github.com/Strilanc/ObjC-CollapsingFutures) looks good, but is not thoroughly documented so a thorough review would require further experimentation.
* [Many others](http://cocoapods.org/?q=promise)

PromiseKit is well tested, and inside apps on the store. It also is fully documented, even within Xcode (⌥ click any method).


#Caveats

* We are version 0.9 and thus reserve the right to remove/change API before 1.0. Probably we won’t; we’re just being prudent by stating this advisory.
* PromiseKit is not thread-safe. This is not intentional, we will fix that. However, in practice the only way to compromise PromiseKit is to keep a pointer to an pending Promise and use that from multiple threads. You can execute thens in many different contexts and the underlying immutability of Promises means PromiseKit is inherently thread-safe.
* If you don't have at least one catch handler in your chain then errors are silently absorbed which may cause you confusion. We intend to log unhandled errors, (with an opt-in method to have them get thrown and thus crash your app in cases where that is desired).


#Promises/A+ Compliance

PromiseKit is [compliant](http://promisesaplus.com) excluding:

* Our `then` does not take a failure handler, instead we have a dedicated `catch`
* Returning an `NSError *` from a `then` or `catch` rejects the returned `Promise`, strictly the specification dictates that only throwing should reject a promise.
* Strictly you should be able to fulfill a Promise with any object, however we do not allow you to fulfill a Promise with an `NSError` object. If you do, the Promise is rejected.

If you find further non-compliance please open a [ticket](https://github.com/mxcl/PromiseKit/issues/new).


## Beyond Promises/A+

* Promises can be fulfilled with multiple arguments which are then passed to the next `then`
* We offer a `when`/`all`
* We offer an `until`


#Terminology

* Promises start in a **pending** state.
* Promises **resolve** with a **value** to become **fulfilled** or **rejected**.


#The Fine Print

The fine print of PromiseKit is mostly exactly what you would expect, so don’t confuse yourself: only come back here when you find yourself curious about more advanced techniques.

* Returning a Promise as the value of a `then` (or `catch`) handler will cause any subsequent handlers to wait for that Promise to resolve.
* Returning an instance of `NSError` or throwing an exception within a then block will cause PromiseKit to bubble that object up to the *next* nearest catch handler.
* `catch` handlers are *always* passed an `NSError` object.
* `then` handlers that follow `catch` handlers **will** execute.
* Returning an `NSError` (or `@throw`ing) from a `catch` will “throw” to the next catch.
* Returning a non-error value from a `catch` will pass that value to the next `then`
* Nothing happens if you add a `then` to a failed Promise (unless you subsequently add a `catch` handler to the Promise returned from that `then`)


#Advanced Examples

## 1. Continuation

Eventually one wonders if a `then` that follows a `catch` that has triggered runs:

{% highlight objectivec %}
self.kitten.then(^(UIImage *image){
    
}).finally(^{
    // always executes
}).catch(^{
    
}).then(^{
    // provided the above catch did not throw or return an
    // `NSError` this then will always execute
})
{% endhighlight %}

The answer is: yes, it does. If you need the catch to completely stop your chain you must either throw again (often: a code smell), or restructure your promises; probably you didn’t want them to chain in this manner.


## 2. Semi-recoverability

Sometimes you have promises that are semi-recoverable. Rather than lump all error handling together and figure out the error with `if` statements instead add a catch to that promise directly. It leads to a little rightward-drift, but it is the best way to implement semi-recoverability.

{% highlight objectivec %}
self.fetch.then(^(id json){
    return [CLLocationManager promise].catch(^(NSError *err){
        if (err.code == kCLErrorLocationUnknown)
            return self.chicagoLocation;
    });
}).then(^{
    //…
})
{% endhighlight %}

This can be especially important when using `when`/`all` since those methods will immediately reject their promise if any of the promises provided them rejects, often one can recover at least some of the provided promises.


## 3. Cache & Fetch

In the case where you have the persisted, cached value for some asynchronous object and you want to show the user that, but also fetch the fresh data and then show the user that:

{% highlight objectivec %}
- (Promise *)fetch {
    return dispatch_promise(^{
        id fresh = [NSURLConnection GET:self.fetchURL];  // start fetching ASAP
        id cached = [NSData dataWithContentsOfFile:…];  // hence dispatch_…
        return PMKManifold(cached, fresh);
    });
}

- (void)go {
    self.fetch.then(^(NSData *cachedData, Promise *freshData) {
        [self updateWithData:cachedData];
        return freshData;
    }).then(^(NSData *freshData){
        [self updateWithData:freshData];
    });
}
{% endhighlight %}


#Cancellation & Progress

A good asynchronous framework provides cancellation and progress information. Our thinking with PromiseKit is that `NSProgress` is the right tool. Feel free to submit issues that discuss how this might work.
